use std::str::FromStr;
use ast::{Expr, ConstDecl, WireDecl, WireWidth, WireValue, BinOpCode, UnOpCode, MuxOption, Assignment, RegisterBankDecl, RegisterDecl, Statement};
use errors::Error;
use lalrpop_util::{ErrorRecovery, ParseError};

// ErrorRecovery< locationType, tokenType, errorType >
grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, (usize, &'input str), Error>>);

match {
    "&&", // over &
    "||",
    ">=", // over >
    ">>",
    "<=",
    "<<",
    "!=", // over !
    "wire",
    "const",
    "register",
    r"0b[01]+" => BIN,
    r"0x[0-9a-fA-F]+" => HEX,
    r"0o[0-7]+" => OCT,
} else {
    r"[0-9]+" => DEC,
} else {
    r"\w+" => ID,
    _
}

Repeat<delim, T>: Vec<T> = {
    <v:(<T> delim)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Comma<T>: Vec<T> = Repeat<",", T>;

Semicolon<T>: Vec<T> = Repeat<";", T>;

WidthConstant : WireWidth = {
    <w:DEC> =>? match WireWidth::from_str(w) {
        Ok(width) => Ok(width),
        Err(_) => {
            errors.push(ErrorRecovery {
                error: ParseError::User { error: Error::InvalidWireWidth(String::from(w)) },
                dropped_tokens: vec!(),
            });
            // Custom lexer to allow this to work?
            Err(ParseError::User { error: () })
        },
    },
    <w:HEX> =>? match WireWidth::from_str(w) {
        Ok(width) => Ok(width),
        Err(_) => {
            errors.push(ErrorRecovery {
                error: ParseError::User { error: Error::InvalidWireWidth(String::from(w)) },
                dropped_tokens: vec!(),
            });
            // Custom lexer to allow this to work?
            Err(ParseError::User { error: () })
        },
    },
};

WireDecl : WireDecl = {
    <name:ID> ":" <width:WidthConstant> =>
        WireDecl { name: String::from(name), width: width },
};

pub WireDecls : Vec<WireDecl> = {
    "wire" <c:Comma<WireDecl>> => c
};

// FIXME: ConstDecls

ConstDecl : ConstDecl = {
    <name:ID> "=" <e:Expr> => ConstDecl { name: String::from(name), value: e }
};

pub ConstDecls : Vec<ConstDecl> = {
    "const" <c:Comma<ConstDecl>> => c
};

BinOpAddSub : BinOpCode = {
    "+" => BinOpCode::Add,
    "-" => BinOpCode::Sub,
};

BinOpAnd : BinOpCode = {
    "&" => BinOpCode::And,
};

BinOpXor : BinOpCode = {
    "^" => BinOpCode::Xor,
};

BinOpOr : BinOpCode = {
    "|" => BinOpCode::Or,
};

BinOpMulDiv : BinOpCode = {
    "*" => BinOpCode::Mul,
    "/" => BinOpCode::Div,
};

BinOpCompare : BinOpCode = {
    "==" => BinOpCode::Equal,
    "!=" => BinOpCode::NotEqual,
    "<=" => BinOpCode::LessEqual,
    ">=" => BinOpCode::GreaterEqual,
    "<" => BinOpCode::Less,
    ">" => BinOpCode::Greater,
};

BinOpLogicalAnd : BinOpCode = {
    "&&" => BinOpCode::LogicalAnd,
};

BinOpLogicalOr : BinOpCode = {
    "||" => BinOpCode::LogicalOr,
};

BinOpShift : BinOpCode = {
    "<<" => BinOpCode::LeftShift,
    ">>" => BinOpCode::RightShift,
};

BinTier<Op,NextTier> : Box<Expr> = {
    <l:BinTier<Op,NextTier>> <o:Op> <r:NextTier> =>
        Box::new(Expr::BinOp(o, l, r)),
    NextTier
};

ExprLogicalOr = BinTier<BinOpLogicalOr, ExprLogicalAnd>;
ExprLogicalAnd = BinTier<BinOpLogicalAnd, ExprCompare>;
ExprCompare = BinTier<BinOpCompare, ExprOr>;
ExprOr = BinTier<BinOpOr, ExprXor>;
ExprXor = BinTier<BinOpXor, ExprAnd>;
ExprAnd = BinTier<BinOpAnd, ExprShift>;
ExprShift = BinTier<BinOpShift, ExprAddSub>;
ExprAddSub = BinTier<BinOpAddSub, ExprMulDiv>;
ExprMulDiv = BinTier<BinOpMulDiv, Term>;

UnOp : UnOpCode = {
    "-" => UnOpCode::Negate,
    "~" => UnOpCode::Complement,
};

MuxOption : MuxOption = {
    <l:Expr> ":" <r:Expr> => MuxOption { condition: l, value: r },
};

MuxOptions = Semicolon<MuxOption>;

// FIXME: handle numbers being too large
pub Term : Box<Expr> = {
    DEC => Box::new(Expr::Constant(WireValue::from_decimal(<>))),
    HEX => Box::new(Expr::Constant(WireValue::from_hexadecimal(&<>[2..]))),
    BIN => Box::new(Expr::Constant(WireValue::from_binary(&<>[2..]))),
    "(" <e:Expr> ")" => e,
    <u:UnOp> <t:Term> => Box::new(Expr::UnOp(u, t)),
    "[" <e:MuxOptions> "]" => Box::new(Expr::Mux(e)),
    ID => Box::new(Expr::NamedWire(String::from(<>)))
};

pub Expr: Box<Expr> = {
    ExprLogicalOr,
};

Assignment : Assignment = {
    <n:(<ID> "=")+> <v:Expr> => {
        let mut names: Vec<String> = Vec::new();
        for name in n {
            names.push(String::from(name));
        }
        Assignment { names: names, value: v }
    }
};

RegisterDecl : RegisterDecl = {
    <n:ID> ":" <w:WidthConstant> "=" <e:Expr> => {
        RegisterDecl { name: String::from(n), width: w, default: e }
    },
};

RegisterBankDecl : RegisterBankDecl = {
    "register" <i:ID> "{" <r:Semicolon<RegisterDecl>> "}" => {
        RegisterBankDecl {
            name: String::from(i),
            registers: r,
        }
    }
};


StatementNeedSemi : Statement = {
    Assignment => Statement::Assignment(<>),
    WireDecls => Statement::WireDecls(<>),
    ConstDecls => Statement::ConstDecls(<>),
};

StatementNoSemi : Statement = {
    RegisterBankDecl => Statement::RegisterBankDecl(<>),
};

pub Statement : Statement = {
    <s:StatementNeedSemi> => s,
    <s:StatementNoSemi> => s,
};

StatementSemicolon : Statement = {
    <s:StatementNeedSemi> ";" => s,
    <s:StatementNoSemi> => s,
};

// Require semicolons between assignments and wire and const declarations, but not
// after register bank declaration
StatementsNotEof : Vec<Statement> = {
    <e:StatementNeedSemi> ";" => {
        let mut v = Vec::new();
        v.push(e);
        v
    },
    <e:StatementNoSemi> => {
        let mut v = Vec::new();
        v.push(e);
        v
    },
    <v:StatementsNotEof> ";" => v,
    <v:StatementsNotEof> <e:StatementNeedSemi> ";" => {
        let mut v = v;
        v.push(e);
        v
    },
    <v:StatementsNotEof> <e:StatementNoSemi> => {
        let mut v = v;
        v.push(e);
        v
    },
};

pub Statements : Vec<Statement> = {
    <v:StatementsNotEof> <e:StatementNeedSemi?> => {
        match e {
            None => v,
            Some(e) => {
                let mut v = v;
                v.push(e);
                v
            }
        }
    }
};
